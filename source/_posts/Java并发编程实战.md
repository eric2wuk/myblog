

## 目录
#### 前言
* 并发编程可以总结为三个核心问题：分工、同步、互斥。
#### 01-可见性、原子性和有序性问题：并发编程 bug 的源头

#### 02-Java内存模型:看Java如何解决可见性和有序性问题

##### Java内存模型 
1. 为什么定义Java内存模型？现代计算机体系大部是采用的对称多处理器的体系架构。每个处理器均有独立的寄存器组和缓存，多个处理器可同时执行同一进程中的不同线程，这里称为处理器的乱序执行。在Java中，不同的线程可能访问同一个共享或共享变量。如果任由编译器或处理器对这些访问进行优化的话，很有可能出现无法想象的问题，这里称为编译器的重排序。除了处理器的乱序执行、编译器的重排序，还有内存系统的重排序。因此Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要是针对可见性和有序性。
2. 三个基本原则：原子性、可见性、有序性。
3. Java内存模型涉及的几个关键词：锁、volatile字段、final修饰符与对象的安全发布。其中：第一是锁，锁操作是具备happens-before关系的，解锁操作happens-before之后对同一把锁的加锁操作。实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。第二是volatile字段，volatile字段可以看成是一种不保证原子性的同步但保证可见性的特性，其性能往往是优于锁操作的。但是，频繁地访问 volatile字段也会出现因为不断地强制刷新缓存而影响程序的性能的问题。第三是final修饰符，final修饰的实例字段则是涉及到新建对象的发布问题。当一个对象包含final修饰的实例字段时，其他线程能够看到已经初始化的final实例字段，这是安全的。
4. Happens-Before的7个规则：
(1).程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
(2).管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而"后面"是指时间上的先后顺序。
(3).volatile变量规则：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的"后面"同样是指时间上的先后顺序。
(4).线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
(5).线程终止规则：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
(6).线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
(7).对象终结规则：一个对象的初始化完成(构造函数执行结束)先行发生于它的finalize()方法的开始。
5. Happens-Before的1个特性：传递性。
6. Java内存模型底层怎么实现的？主要是通过内存屏障(memory barrier)禁止重排序的，即时编译器根据具体的底层体系架构，将这些内存屏障替换成具体的 CPU 指令。对于编译器而言，内存屏障将限制它所能做的重排序优化。而对于处理器而言，内存屏障将会导致缓存的刷新操作。比如，对于volatile，编译器将在volatile字段的读写操作前后各插入一些内存屏障

#### 03-互斥锁（上）：解决原子性问题
* 加锁本质就是在锁对象的对象头中写入当前线程id
#### 04-互斥锁（下）：如何用一把锁保护多个资源？
#### 05-一不小心就死锁了，怎么办？
##### 死锁发生条件 --  Coffman
  * 互斥，共享资源X和Y只能被一个线程占用；
  * 占有且等待，线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X；
  * 不可抢占，其他线程不能强行抢占线程T1占有的资源；
  * 循环等待，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。
#### 06-用“等待-通知”机制优化循环等待.html
#### 07-安全性、活跃性以及性能问题
#### 08-管程：并发编程的万能钥匙
#### 09-Java线程（上）：Java线程的生命周期.html
    * 初始状态 创建状态
    * 可运行状态
    * 运行状态
    * 休眠状态
    * 终止状态
#### 10-Java线程（中）：创建多少线程才是合适的？
    * 最佳线程数=CPU核数 * [ 1 +（I/O耗时 / CPU耗时）]
    * 经验公示，当I/O耗时 / CPU耗时 不明确时，初始设置 最佳线程=2 * CPU的核数 + 1
#### 11-Java线程（下）：为什么局部变量是线程安全的？
    * 利用 栈 来保证线程安全